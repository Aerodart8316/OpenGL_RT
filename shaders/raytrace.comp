#version 460 core
layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
layout(rgba32f, location = 0, binding = 0) writeonly uniform image2D img_output;

const float INFINITY = 1.0f / 0.0f;
const float PI = 3.1415926535f;

struct Ray
{
    vec3 origin;
    vec3 direction;
};

struct HitRecord
{
    bool front_face;
    bool hit;
    vec3 point;
    vec3 norm;
    double t;
};

struct Sphere
{
    vec3 center;
    float radius;
};
#define MAX_BOUNCE 5
#define SAMPLES_PER_PIXEL 100
#define WRLD_LEN 2
Sphere world[WRLD_LEN];

vec2 co;

float randomFloat(){

    float val = fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);
    co = vec2(co.y,val);
    return val;
}

float random_normal_dist()
{
    float theta = 2 * 3.14159f * randomFloat();
    float rho = sqrt(-2 * log(randomFloat()));
    return rho * cos(theta);
}

vec3 random_on_sphere()
{
    return normalize(vec3(random_normal_dist(), random_normal_dist(), random_normal_dist()));
}

vec3 random_on_hemisphere(vec3 n)
{
    vec3 s = random_on_sphere();
    if(dot(s,n) > 0)
        return s;
    return -s;
}

vec3 at(Ray r, float dist)
{
    return r.origin + dist*r.direction;
}

HitRecord hit_sphere(Sphere s, Ray r)
{
    float ray_tmin = 0.001f;
    float ray_tmax = 100.0f;

    HitRecord rec;
    rec.hit = false;
    vec3 oc = s.center - r.origin;
    float a = length(r.direction) * length(r.direction);
    float h = dot(r.direction, oc);
    float c = length(oc) * length(oc) - s.radius*s.radius;
    float disc = h*h - a*c;
    if(disc < 0)
    {
        return rec;
    }
    float root = (h - sqrt(disc)) / a;
    if(root <= ray_tmin || root >= ray_tmax) // Min i max za ray
    {
        root = (h + sqrt(disc)) / a;
        if(root <= ray_tmin || root >= ray_tmax)
            return rec;
    }
    rec.hit = true;
    rec.t = root;
    rec.point = at(r,root);
    rec.norm = (rec.point - s.center) / s.radius;
    rec.front_face = true;
    if(dot(r.direction, rec.norm) > 0.0f)
    {
        rec.front_face = false;
        rec.norm = -rec.norm;
    }

    return rec;
}

vec3 ray_color(Ray r, out HitRecord h)
{
    for(int i = 0;i < WRLD_LEN; i++)
    {
        h = hit_sphere(world[i],r);
        if(h.hit)
        {
            return vec3(0.4f);
        }
    }

    vec3 dir = normalize(r.direction);
    float a = 0.5f*(dir.y + 1.0f);
    return (1.0f-a)*vec3(1.0f, 1.0f, 1.0f) + a*vec3(0.5f, 0.7f, 1.0f);
    //return vec3(0.5f,0.75f,0.95f);
}

vec3 trace_ray(Ray r)
{
    vec3 pixel_color = vec3(0,0,0);
    HitRecord hr;
    for(int i = 0;i < SAMPLES_PER_PIXEL; i++)
    {
        Ray cp = r;
        vec3 col = vec3(1);
        for(int j = 0;j<MAX_BOUNCE;j++)
        {
            vec3 temp = ray_color(cp, hr);
            col *= temp;
            if(!hr.hit)
                break;
            else
            {
                cp.origin = hr.point;
                cp.direction = random_on_sphere() + hr.norm;
            }
        }
        pixel_color += col;
    }
    return pixel_color / SAMPLES_PER_PIXEL;
}

void main() {
    world[0] = Sphere(vec3(0.0f,0.0f,-1.0f), 0.5f); // Ovo treba kasnije iz buffera da se cita (SSBO probs)
    world[1] = Sphere(vec3(0.0f,-100.5f,-1.0f), 100.0f);

    co = gl_GlobalInvocationID.xy;
    ivec2 texel_coord = ivec2(gl_GlobalInvocationID.xy);
	ivec2 image_dimensions = imageSize(img_output);

    vec3 camera_center = vec3(0.0f,0.0f,0.0f);

    float focal_length = 1.0f;
    float viewport_height = 2.0f;
    float viewport_width = viewport_height * (float(image_dimensions.x) / image_dimensions.y);

    vec3 viewport_bottom_left = camera_center - vec3(viewport_width/2.0f,viewport_height/2.0f,focal_length);

    vec3 viewport_location = viewport_bottom_left + vec3(texel_coord.x * (viewport_width/image_dimensions.x), texel_coord.y * (viewport_height/image_dimensions.y), 0.0f);

    Ray r;
    r.origin = camera_center;
    r.direction = viewport_location - camera_center;

    vec3 r_color = trace_ray(r);

    imageStore(img_output, texel_coord, vec4(r_color, 1.0f));
}
