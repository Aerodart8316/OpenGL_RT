#version 460 core
layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
layout(rgba32f, location = 0, binding = 0) writeonly uniform image2D img_output;

struct Ray
{
    vec3 origin;
    vec3 direction;
};

uint rand;
const uint a = 1664525u;
const uint c = 1013904223u;

uint lcg(uint x) {
    return a * x + c;
}

float randomFloat() {
    rand = lcg(rand);
    return float(rand & 0x00FFFFFFu) / float(0x01000000u);
}

float random_normal_dist()
{
    float theta = 2 * 3.14159f * randomFloat();
    float rho = sqrt(-2 * log(randomFloat()));
    return rho * cos(theta);
}

vec3 random_on_sphere()
{
    return normalize(vec3(random_normal_dist(), random_normal_dist(), random_normal_dist()));
}

vec3 random_on_hemisphere(vec3 n)
{
    vec3 s = random_on_sphere();
    if(dot(s,n) > 0)
        return s;
    return -s;
}

vec3 at(Ray r, float dist)
{
    return r.origin + dist*r.direction;
}

float hit_sphere(float radius, vec3 center, Ray r)
{
    vec3 oc = center - r.origin;
    float a = length(r.direction) * length(r.direction);
    float h = dot(r.direction, oc);
    float c = length(oc) * length(oc) - radius*radius;
    float disc = h*h - a*c;
    if(disc < 0)
        return -1.0f;
    return (h-sqrt(disc))/a;
}

vec3 ray_color(Ray r)
{
    float t = hit_sphere(0.5f,vec3(0.0f,0.0f,-1.0f),r);
    if(t > 0.0f)
    {
        vec3 dir = random_on_hemisphere(norm)
        return 0.5*vec3(norm.x+1, norm.y+1, norm.z+1);
    }

    float t2 = hit_sphere(100.0f,vec3(0.0f,-100.5f,-1.0f),r);
    if(t2 > 0.0f)
    {
        vec3 norm2 = normalize(at(r,t2) - vec3(0.0f,-100.0f,-1.0f));
        return 0.5*vec3(norm2.x+1, norm2.y+1, norm2.z+1);
    }

    vec3 dir = normalize(r.direction);
    float a = 0.5f*(dir.y + 1.0f);
    return (1.0f-a)*vec3(1.0f, 1.0f, 1.0f) + a*vec3(0.5f, 0.7f, 1.0f);
}

void main() {
    rand = gl_GlobalInvocationID.x + gl_LocalInvocationIndex;
    ivec2 texel_coord = ivec2(gl_GlobalInvocationID.xy);
	ivec2 image_dimensions = imageSize(img_output);

    vec3 camera_center = vec3(0.0f,0.0f,0.0f);

    float focal_length = 1.0f;
    float viewport_height = 2.0f;
    float viewport_width = viewport_height * (float(image_dimensions.x) / image_dimensions.y);

    vec3 viewport_bottom_left = camera_center - vec3(viewport_width/2.0f,viewport_height/2.0f,focal_length);

    vec3 viewport_location = viewport_bottom_left + vec3(texel_coord.x * (viewport_width/image_dimensions.x), texel_coord.y * (viewport_height/image_dimensions.y), 0.0f);

    Ray r;
    r.origin = camera_center;
    r.direction = viewport_location - camera_center;

    vec3 r_color = ray_color(r);

    imageStore(img_output, texel_coord, vec4(r_color, 1.0f));
}
