#version 460 core
layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
layout(rgba32f, location = 0, binding = 0) writeonly uniform image2D img_output;

const float INFINITY = 1.0f / 0.0f;
const float PI = 3.1415926535f;

struct Ray
{
    vec3 origin;
    vec3 direction;
};

struct HitRecord
{
    bool front_face;
    bool hit;
    vec3 point;
    vec3 norm;
    double t;
};

struct Sphere
{
    vec3 center;
    float radius;
};
#define WRLD_LEN 2
Sphere world[WRLD_LEN];

uint rand;
const uint a = 1664525u;
const uint c = 1013904223u;

uint lcg(uint x) {
    return a * x + c;
}

float randomFloat() {
    rand = lcg(rand);
    return float(rand & 0x00FFFFFFu) / float(0x01000000u);
}

float random_normal_dist()
{
    float theta = 2 * 3.14159f * randomFloat();
    float rho = sqrt(-2 * log(randomFloat()));
    return rho * cos(theta);
}

vec3 random_on_sphere()
{
    return normalize(vec3(random_normal_dist(), random_normal_dist(), random_normal_dist()));
}

vec3 random_on_hemisphere(vec3 n)
{
    vec3 s = random_on_sphere();
    if(dot(s,n) > 0)
        return s;
    return -s;
}

vec3 at(Ray r, float dist)
{
    return r.origin + dist*r.direction;
}

HitRecord hit_sphere(Sphere s, Ray r)
{
    float ray_tmin = 0.1f;
    float ray_tmax = 100.0f;

    HitRecord rec;
    rec.hit = false;
    vec3 oc = s.center - r.origin;
    float a = length(r.direction) * length(r.direction);
    float h = dot(r.direction, oc);
    float c = length(oc) * length(oc) - s.radius*s.radius;
    float disc = h*h - a*c;
    if(disc < 0)
    {
        return rec;
    }
    float root = (h - sqrt(disc)) / a;
    if(root <= ray_tmin || root >= ray_tmax) // Min i max za ray
    {
        root = (h + sqrt(disc)) / a;
        if(root <= ray_tmin || root >= ray_tmax)
            return rec;
    }
    rec.hit = true;
    rec.t = root;
    rec.point = at(r,root);
    rec.norm = (rec.point - s.center) / s.radius;
    rec.front_face = true;
    if(dot(r.direction, rec.norm) > 0.0f)
    {
        rec.front_face = false;
        rec.norm = -rec.norm;
    }

    return rec;
}

vec3 ray_color(Ray r)
{
    for(int i = 0;i < WRLD_LEN; i++)
    {
        HitRecord h = hit_sphere(world[i],r);
        if(h.hit)
        {
            return h.norm;
        }
    }

    vec3 dir = normalize(r.direction);
    float a = 0.5f*(dir.y + 1.0f);
    return (1.0f-a)*vec3(1.0f, 1.0f, 1.0f) + a*vec3(0.5f, 0.7f, 1.0f);
}

void main() {
    world[0] = Sphere(vec3(0.0f,0.0f,-1.0f), 0.5f); // Ovo treba kasnije iz buffera da se cita (SSBO probs)
    world[1] = Sphere(vec3(0.0f,-100.5f,-1.0f), 100.0f);

    rand = gl_GlobalInvocationID.x + gl_LocalInvocationIndex;
    ivec2 texel_coord = ivec2(gl_GlobalInvocationID.xy);
	ivec2 image_dimensions = imageSize(img_output);

    vec3 camera_center = vec3(0.0f,0.0f,0.0f);

    float focal_length = 1.0f;
    float viewport_height = 2.0f;
    float viewport_width = viewport_height * (float(image_dimensions.x) / image_dimensions.y);

    vec3 viewport_bottom_left = camera_center - vec3(viewport_width/2.0f,viewport_height/2.0f,focal_length);

    vec3 viewport_location = viewport_bottom_left + vec3(texel_coord.x * (viewport_width/image_dimensions.x), texel_coord.y * (viewport_height/image_dimensions.y), 0.0f);

    Ray r;
    r.origin = camera_center;
    r.direction = viewport_location - camera_center;

    vec3 r_color = ray_color(r);

    imageStore(img_output, texel_coord, vec4(r_color, 1.0f));
}
