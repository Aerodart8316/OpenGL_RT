#version 460 core

struct Material
{
    vec3 albedo;
    vec3 emmision_color;
    float emmision_strength;
    float smoothness;
};

struct Vertex
{
    vec3 position;
    vec3 normal;
    vec2 tex_coords;
};

struct Mesh
{
    Material material;
    int indices_start;
    int indices_num;
};

struct Ray
{
    vec3 origin;
    vec3 direction;
};

struct HitRecord
{
    bool front_face;
    bool hit;
    vec3 point;
    vec3 norm;
    float t;
    Material hit_material;
};


layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
layout(rgba32f, location = 0, binding = 0) writeonly uniform image2D img_output;

layout(std430, binding = 1) buffer vertices
{
    Vertex data_vertices[];
};
layout(std430, binding = 2) buffer indices
{
    int data_indices[];
};
layout(std430, binding = 3) buffer meshes
{
    Mesh data_meshes[];
};

uniform int mesh_count;

const float INFINITY = 1.0f / 0.0f;
const float PI = 3.1415926535f;


#define MAX_BOUNCE 8
#define SAMPLES_PER_PIXEL 4
#define GLOBAL_LIGHT vec3(0.53, 0.81, 0.92);

uint state;

float randomFloat()
{
    state *= (state + 195439) * (state + 124395) * (state + 845921);
    return state / 4294967295.0;
}

float random_normal_dist()
{
    float theta = 2 * 3.14159f * randomFloat();
    float rho = sqrt(-2 * log(randomFloat()));
    return rho * cos(theta);
}

vec3 random_on_sphere()
{
    return normalize(vec3(random_normal_dist(), random_normal_dist(), random_normal_dist()));
}

vec3 random_on_hemisphere(vec3 n)
{
    vec3 s = random_on_sphere();
    if(dot(s,n) > 0)
        return s;
    return -s;
}

vec3 at(Ray r, float dist)
{
    return r.origin + dist*r.direction;
}

HitRecord hit_triangle(int ind1, int ind2, int ind3, Ray r)
{
    Vertex vertA = data_vertices[ind1];
    Vertex vertB = data_vertices[ind2];
    Vertex vertC = data_vertices[ind3];

    vec3 edgeAB = vertB.position - vertA.position;
    vec3 edgeAC = vertC.position - vertA.position;

    vec3 normal_vec = cross(edgeAB,edgeAC);
    vec3 ao = r.origin - vertA.position;
    vec3 dao = cross(ao, r.direction);

    float det = -dot(r.direction, normal_vec);
    float inv_det = 1 / det;

    float dist = dot(ao, normal_vec) * inv_det;
    float u = dot(edgeAC, dao) * inv_det;
    float v = -dot(edgeAB, dao) * inv_det;
    float w = 1 - u - v;

    HitRecord result;
    result.hit = det >= 1e-6 && dist >= 0 && u >= 0 && v >= 0 && w >= 0;
    result.t = dist;
    result.point = at(r, dist);
    result.norm = normalize(vertA.normal * w + vertB.normal * u + vertC.normal * v);
    return result;
}

HitRecord calculate_collision(Ray r)
{
    HitRecord closestHit;
    closestHit.hit = false;
    closestHit.hit_material.albedo = vec3(0);
    float closest = INFINITY;
    for(int i = 0;i< mesh_count;i++)
    {
        for(int j = 0; j < data_meshes[i].indices_num; j += 3)
        {
            HitRecord temp = hit_triangle(data_indices[data_meshes[i].indices_start + j], data_indices[data_meshes[i].indices_start + j +1], data_indices[data_meshes[i].indices_start + j +2], r);

            if(temp.hit && temp.t < closest)
            {
                closestHit = temp;
                closestHit.hit_material = data_meshes[i].material;
                closest = temp.t;
            }
        }
    }
    return closestHit;
}

vec3 trace_ray(Ray r)
{
    vec3 pixel_color = vec3(0,0,0);
    for(int i = 0; i < SAMPLES_PER_PIXEL; i++)
    {
        Ray cp = r;
        vec3 ray_col = vec3(1);
        vec3 in_light = vec3(0);
        for(int j = 0; j< MAX_BOUNCE;j++)
        {
            HitRecord hr = calculate_collision(cp);
            if(hr.hit)
            {
                cp.origin = hr.point;
                vec3 diffuse_dir = random_on_sphere() + hr.norm;
                vec3 specular_dir = reflect(cp.direction, hr.norm);
                cp.direction = mix(diffuse_dir,specular_dir,hr.hit_material.smoothness);
                vec3 emmited_light = hr.hit_material.emmision_color * hr.hit_material.emmision_strength;
                in_light += emmited_light * ray_col;
                ray_col *= hr.hit_material.albedo;
            }
            else
            {
                in_light += ray_col * GLOBAL_LIGHT;
                break;
            }
        }
        pixel_color += in_light;
    }
    return pixel_color / SAMPLES_PER_PIXEL;
}

void main() {    
    ivec2 texel_coord = ivec2(gl_GlobalInvocationID.xy);
	ivec2 image_dimensions = imageSize(img_output);
    state = gl_GlobalInvocationID.x + image_dimensions.x * gl_GlobalInvocationID.y;

    // Camera parameters
    vec3 camera_center = vec3(0.0f,2.0f,5.0f);
    vec3 look_at = vec3(1,0,0);
    float focal_length = 1.0f;
    float fov = 90.0f;

    vec3 w,u,v;
    w = normalize(camera_center - look_at);
    u = normalize(cross(vec3(0,1,0),w));
    v = cross(w,u);

    float theta = radians(fov);
    float viewport_height = 2 * focal_length * tan(theta / 2);
    float viewport_width = viewport_height * (float(image_dimensions.x) / image_dimensions.y);

    vec3 viewport_u = viewport_width * u;
    vec3 viewport_v = viewport_height * v;

    vec3 viewport_bottom_left = camera_center - focal_length * w - viewport_u/2 - viewport_v/2;

    vec3 viewport_location = viewport_bottom_left + texel_coord.x * (viewport_u/image_dimensions.x) + texel_coord.y * (viewport_v/image_dimensions.y);

    Ray r;
    r.origin = camera_center;
    r.direction = viewport_location - camera_center;

    vec3 r_color = trace_ray(r);
    imageStore(img_output, texel_coord, vec4(r_color, 1.0f));
}
