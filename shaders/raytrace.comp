#version 460 core
layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
layout(rgba32f, location = 0, binding = 0) writeonly uniform image2D img_output;

const float INFINITY = 1.0f / 0.0f;
const float PI = 3.1415926535f;

struct Material
{
    vec3 albedo;
    vec3 emmision_color;
    float emmision_strength;
};

struct Ray
{
    vec3 origin;
    vec3 direction;
};

struct HitRecord
{
    bool front_face;
    bool hit;
    vec3 point;
    vec3 norm;
    float t;
    Material hit_material;
};

struct Sphere
{
    vec3 center;
    float radius;
    Material material;
};
#define MAX_BOUNCE 2
#define SAMPLES_PER_PIXEL 50
#define WRLD_LEN 3
#define GLOBAL_LIGHT vec3(0.1f);
Sphere world[WRLD_LEN];

uint state;

float randomFloat()
{
    state *= (state + 195439) * (state + 124395) * (state + 845921);
    return state / 4294967295.0;
}

float random_normal_dist()
{
    float theta = 2 * 3.14159f * randomFloat();
    float rho = sqrt(-2 * log(randomFloat()));
    return rho * cos(theta);
}

vec3 random_on_sphere()
{
    return normalize(vec3(random_normal_dist(), random_normal_dist(), random_normal_dist()));
}

vec3 random_on_hemisphere(vec3 n)
{
    vec3 s = random_on_sphere();
    if(dot(s,n) > 0)
        return s;
    return -s;
}

vec3 at(Ray r, float dist)
{
    return r.origin + dist*r.direction;
}

HitRecord hit_sphere(Sphere s, Ray r)
{
    float ray_tmin = 0.001f;
    float ray_tmax = 100.0f;

    HitRecord rec;
    rec.hit = false;
    vec3 oc = s.center - r.origin;
    float a = length(r.direction) * length(r.direction);
    float h = dot(r.direction, oc);
    float c = length(oc) * length(oc) - s.radius*s.radius;
    float disc = h*h - a*c;
    if(disc < 0)
    {
        return rec;
    }
    float root = (h - sqrt(disc)) / a;
    if(root <= ray_tmin || root >= ray_tmax) // Min i max za ray
    {
        root = (h + sqrt(disc)) / a;
        if(root <= ray_tmin || root >= ray_tmax)
            return rec;
    }
    rec.hit = true;
    rec.t = root;
    rec.point = at(r,root);
    rec.norm = (rec.point - s.center) / s.radius;
    rec.front_face = true;
    rec.hit_material = s.material;
    if(dot(r.direction, rec.norm) > 0.0f)
    {
        rec.front_face = false;
        rec.norm = -rec.norm;
    }

    return rec;
}

HitRecord calculate_collision(Ray r)
{
    HitRecord closestHit;
    closestHit.hit = false;
    closestHit.hit_material.albedo = vec3(0);
    float closest = INFINITY;
    for(int i = 0;i<WRLD_LEN;i++)
    {
        HitRecord temp = hit_sphere(world[i], r);
        if(temp.hit && temp.t < closest)
        {
            closestHit = temp;
            closestHit.hit_material = temp.hit_material;
            closest = temp.t;
        }
    }
    return closestHit;
}

vec3 trace_ray(Ray r)
{
    vec3 pixel_color = vec3(0,0,0);
    for(int i = 0; i < SAMPLES_PER_PIXEL; i++)
    {
        Ray cp = r;
        vec3 ray_col = vec3(1);
        vec3 in_light = vec3(0);
        for(int j = 0; j< MAX_BOUNCE;j++)
        {
            HitRecord hr = calculate_collision(cp);
            if(hr.hit)
            {
                cp.origin = hr.point;
                cp.direction = random_on_sphere() + hr.norm;
                vec3 emmited_light = hr.hit_material.emmision_color * hr.hit_material.emmision_strength;
                in_light += emmited_light * ray_col;
                ray_col *= hr.hit_material.albedo;
            }
            else
            {
                in_light += ray_col * GLOBAL_LIGHT;
                break;
            }
        }
        pixel_color += in_light;
    }
    return pixel_color / SAMPLES_PER_PIXEL;
}

/*vec3 ray_color(Ray r, out HitRecord h)
{
    for(int i = 0;i < WRLD_LEN; i++)
    {
        h = hit_sphere(world[i],r);
        if(h.hit)
        {
            return vec3(0.4f);
        }
    }

    vec3 dir = normalize(r.direction);
    float a = 0.5f*(dir.y + 1.0f);
    return (1.0f-a)*vec3(1.0f, 1.0f, 1.0f) + a*vec3(0.5f, 0.7f, 1.0f);
    //return vec3(0.5f,0.75f,0.95f);
}

vec3 trace_ray(Ray r)
{
    vec3 pixel_color = vec3(0,0,0);
    HitRecord hr;
    for(int i = 0;i < SAMPLES_PER_PIXEL; i++)
    {
        Ray cp = r;
        vec3 col = vec3(1);
        for(int j = 0;j<MAX_BOUNCE;j++)
        {
            vec3 temp = ray_color(cp, hr);
            col *= temp;
            if(!hr.hit)
                break;
            else
            {
                cp.origin = hr.point;
                cp.direction = random_on_sphere() + hr.norm;
            }
        }
        pixel_color += col;
    }
    return pixel_color / SAMPLES_PER_PIXEL;
}*/



void main() {
    world[0] = Sphere(vec3(-1.0f,0.0f,-1.0f), 0.25f, Material(vec3(0.8f), vec3(1), 10)); // Ovo treba kasnije iz buffera da se cita (SSBO probs)
    world[1] = Sphere(vec3(0.0f,-100.5f,-1.0f), 100.0f, Material(vec3(0.9f,0.1f,0.1f), vec3(0), 0));
    world[2] = Sphere(vec3(1.0f,0.0f,-1.0f), 0.5f, Material(vec3(0.1f,0.1f,0.9f), vec3(0), 0));

    
    ivec2 texel_coord = ivec2(gl_GlobalInvocationID.xy);
	ivec2 image_dimensions = imageSize(img_output);
    state = gl_GlobalInvocationID.x + image_dimensions.x * gl_GlobalInvocationID.y;
    vec3 camera_center = vec3(0.0f,0.0f,0.0f);

    float focal_length = 1.0f;
    float viewport_height = 2.0f;
    float viewport_width = viewport_height * (float(image_dimensions.x) / image_dimensions.y);

    vec3 viewport_bottom_left = camera_center - vec3(viewport_width/2.0f,viewport_height/2.0f,focal_length);

    vec3 viewport_location = viewport_bottom_left + vec3(texel_coord.x * (viewport_width/image_dimensions.x), texel_coord.y * (viewport_height/image_dimensions.y), 0.0f);

    Ray r;
    r.origin = camera_center;
    r.direction = viewport_location - camera_center;

    vec3 r_color = trace_ray(r);
    imageStore(img_output, texel_coord, vec4(r_color, 1.0f));
}
